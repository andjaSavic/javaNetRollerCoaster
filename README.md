# javaNetRollerCoaster
1. Kreirati interfejs sa metodama i konkurentni monitor koji implementira te metode
2. Korak kreiranje Server.java - napravljen kao neka usluzna klasa zbog cega je run staticka i privatna metoda. Ne znam kako da ugasim server...
3. Kreiram WorkingThread/RequestHandler klasu - u serveru se pokrece zasebnu nit, zaseban tok kontrole za svakom klijenta, tj. za komunikaciju sa svakim klijentom. Ova klasa extend-uje klasu Thread, a prosledjujemo joj referencu tipa RCInterface (u koju je u Serveru spakovan objekat klase RollercoasterMonitor). Klijent salje ime operacije i id (ako je putnik)/kapacitet(ako je vozilo) kao jedan Objekat, odatle se na osnovu operacije u switch-u poziva odgovarajuca sinhronizovana metoda RollercoasterMonitor-a. Nakon toga se salje poruka klijentu, koja ce se ispisati u main-u na system.output. Napomena: readObject je blokirajuca metoda + nakon writeObject obavezno uraditi out.flush(), da bi mi se objekat odmah poslao u prikljucnicu. Kreiram poseban in i out stream za svakog klijenta! Svaki klijent se u svojoj service klasi kreirati novi soket objekat (novu prikljucnicu) za isti port i host (to je ok), i onda ce server da prihvati tu prikljucnicu sa server.accept() i da je prosledi niti 
RequestHandler, zato imam Socket client = this.sock;)
3. Kreiranje Service(RollerCoasterNet) klase za svakog klijenta. Vrlo vazno je da svaka metoda koristi try - with - resources, to jest u zagradama kod try kreira svaki put NOVI soket i novi input i output stream, koje potom po zavrsetku metode oslobadja i automatski zatvara (AutoClosable). I ova klasa mora implementirati RCInterface!(Mora li?) Vrlo BITNOOO: dobra praksa je uvek prvo otvoriti na obe strane koje komuniciraju u ovom slucaju u RequestHandleru i Service (RollerCoaster) klasi prvo ObjectOutputStream, pa tek onda ObjectInputStream konstruktor!!!
Iz knjige:
U konstruktoru ulaznog toka podataka cita se zaglavlje toka kako bi se verifikovalo da je tok odgovarajuci. Konstruktor ce se blokirati sve dok odgovarajuci izlazni tok ObjectOutputStream sa druge strane ne upise zaglavlje u tok i dok ga ne prosledi. Ukoliko bi obe strane prvo pokusale da otvore ulazni objektni tok doslo bi do MRTVOG blokiranja, deadlock, jer bi se ove strane medjusobno cekale. Kako bi se ovo otklonilo, potrebno je da barem jedna strana otvori prvo izlazni, pa tek onda ulazni objektni tok.
Na System.out() ispisacemo poruku koju nam RequestHandler prosledi nakon sto se pozove odgovarajuca metoda koju smo hteli pozvati.
5. Kreiranje klijentskih klasa - Passenger i RCar koje prosiruju klasu Thread. U svom konstruktoru primaju jedan ist RollerCoasterNet objekat, dakle jedan objekat servisne klase za sve klijente, samo se pri pozivu metoda tog jednog objekta kreira svaki put novi soket za svakog kljenta, zato nema problema. Klijenti su niti, imaju run metodu u kojoj pozivaju metode RollerCoasterNet klase.
6. Kreiranje Main.java (test klasa) - samo za klijente (za njihov RollerCoasterNet objekat prosledjujemo i ime servera "loacalhost"). 5555-port na serveru koji osluskujemo za sve klijente.
//TO DO: nemam pojma kako server da ugasim, kako napraviti da radi sa vise vozila, a ne samo sa jednim?
